/**
 * GitManager - Manages git auto-commit functionality for task implementation
 *
 * This class handles:
 * - Checking git repository status
 * - Creating commits based on user preferences
 * - Generating commit messages
 * - Handling commit strategies (per task, per phase, per N tasks)
 */

import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

/**
 * Git commit strategy options
 */
export type CommitStrategy =
  | 'per-phase' // Commit when all tasks in a phase are complete
  | 'per-5-tasks' // Commit after every 5 tasks
  | 'per-task' // Commit after each individual task
  | 'none'; // No auto-commits

/**
 * Options for creating a commit
 */
export interface CommitOptions {
  message?: string; // Full commit message (if provided, description is ignored)
  description?: string; // Task description (used if message not provided)
  tasks?: string[]; // Task descriptions to include in commit message
  phase?: string; // Optional phase name
  projectName?: string; // Optional project name for context
}

/**
 * GitManager class
 *
 * Handles git operations for the implement command
 */
export class GitManager {
  /**
   * Check if current directory is a git repository
   */
  async isGitRepository(): Promise<boolean> {
    try {
      await execAsync('git rev-parse --git-dir');
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Check if there are uncommitted changes
   */
  async hasUncommittedChanges(): Promise<boolean> {
    try {
      const { stdout } = await execAsync('git status --porcelain');
      return stdout.trim().length > 0;
    } catch {
      return false;
    }
  }

  /**
   * Create a commit with the given tasks
   */
  async createCommit(options: CommitOptions): Promise<boolean> {
    try {
      // Check for changes first
      if (!(await this.hasUncommittedChanges())) {
        return false; // No changes to commit
      }

      // Stage all changes
      await execAsync('git add .');

      // Use provided message or generate one
      const message = options.message ?? this.generateCommitMessage(options);

      // Create commit
      await execAsync(`git commit -m "${this.escapeCommitMessage(message)}"`);

      return true;
    } catch (error) {
      // If commit fails, log but don't throw
      console.error('Git commit failed:', error);
      return false;
    }
  }

  /**
   * Generate commit message from tasks
   */
  private generateCommitMessage(options: CommitOptions): string {
    const { description, tasks = [], phase, projectName } = options;

    let message = '';

    // Header
    if (phase) {
      message += `clavix: ${phase}\n\n`;
    } else if (description) {
      message += `clavix: ${description}\n\n`;
    } else if (tasks.length === 1) {
      message += `clavix: ${tasks[0]}\n\n`;
    } else if (tasks.length > 1) {
      message += `clavix: implement ${tasks.length} tasks\n\n`;
    } else {
      message += `clavix: task completed\n\n`;
    }

    // Task list (if provided)
    if (tasks.length > 0) {
      message += 'Completed tasks:\n';
      tasks.forEach((task) => {
        message += `- ${task}\n`;
      });
      message += '\n';
    }

    // Footer
    if (projectName) {
      message += `Project: ${projectName}\n`;
    }
    message += 'Generated by Clavix /clavix:implement';

    return message;
  }

  /**
   * Validate that tasks are marked before committing
   * This ensures the tasks.md file matches what we expect to commit
   * @param tasksPath - Path to tasks.md file
   * @param completedTaskIds - Array of task IDs that should be completed
   * @returns Validation result with any errors
   */
  async validateBeforeCommit(
    tasksPath: string,
    completedTaskIds: string[]
  ): Promise<{ valid: boolean; errors?: string[] }> {
    const errors: string[] = [];

    try {
      // Read tasks.md file
      const fsExtra = await import('fs-extra');
      const fs = fsExtra.default || fsExtra;
      if (!(await fs.pathExists(tasksPath))) {
        errors.push(`Tasks file not found: ${tasksPath}`);
        return { valid: false, errors };
      }

      const content = await fs.readFile(tasksPath, 'utf-8');

      // Check each task ID is marked as complete in the file
      for (const taskId of completedTaskIds) {
        // Look for the task in the file (should have [x] checkbox)
        const hasCompleteCheckbox = content.includes(`[x]`) && content.includes(taskId);

        if (!hasCompleteCheckbox) {
          errors.push(`Task ${taskId} not marked as completed in tasks.md`);
        }
      }

      return {
        valid: errors.length === 0,
        errors: errors.length > 0 ? errors : undefined,
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      errors.push(`Validation failed: ${errorMessage}`);
      return { valid: false, errors };
    }
  }

  /**
   * Create commit with validation
   * Validates that tasks are marked before committing
   * @param options - Commit options
   * @param tasksPath - Path to tasks.md file
   * @param completedTaskIds - Array of task IDs that should be completed
   * @returns Commit result with validation status
   */
  async createCommitWithValidation(
    options: CommitOptions,
    tasksPath?: string,
    completedTaskIds?: string[]
  ): Promise<{ success: boolean; validated: boolean; errors?: string[] }> {
    // If validation info provided, validate first
    if (tasksPath && completedTaskIds) {
      const validation = await this.validateBeforeCommit(tasksPath, completedTaskIds);

      if (!validation.valid) {
        return {
          success: false,
          validated: false,
          errors: validation.errors,
        };
      }
    }

    // Create commit
    const success = await this.createCommit(options);

    return {
      success,
      validated: tasksPath !== undefined && completedTaskIds !== undefined,
    };
  }

  /**
   * Escape commit message for shell
   */
  private escapeCommitMessage(message: string): string {
    return message.replace(/"/g, '\\"').replace(/\n/g, '\\n');
  }

  /**
   * Get the current branch name
   */
  async getCurrentBranch(): Promise<string> {
    try {
      const { stdout } = await execAsync('git rev-parse --abbrev-ref HEAD');
      return stdout.trim();
    } catch {
      return 'unknown';
    }
  }

  /**
   * Check if working directory is clean
   */
  async isWorkingDirectoryClean(): Promise<boolean> {
    return !(await this.hasUncommittedChanges());
  }

  /**
   * Get short status for display
   */
  async getStatus(): Promise<string> {
    try {
      const { stdout } = await execAsync('git status --short');
      return stdout.trim();
    } catch {
      return 'Unable to get git status';
    }
  }

  /**
   * Validate git setup before implementing
   */
  async validateGitSetup(): Promise<{
    isRepo: boolean;
    hasChanges: boolean;
    currentBranch: string;
  }> {
    const isRepo = await this.isGitRepository();
    const hasChanges = await this.hasUncommittedChanges();
    const currentBranch = isRepo ? await this.getCurrentBranch() : '';

    return {
      isRepo,
      hasChanges,
      currentBranch,
    };
  }
}

/**
 * Helper class to track when to commit based on strategy
 */
export class CommitScheduler {
  private completedTasksInPhase: number = 0;
  private completedTasksTotal: number = 0;
  private completedTasksSinceLastCommit: number = 0;
  private currentPhase: string = '';

  constructor(private strategy: CommitStrategy) {}

  /**
   * Mark a task as completed and check if commit should be made
   */
  taskCompleted(taskPhase: string): boolean {
    this.completedTasksTotal++;
    this.completedTasksSinceLastCommit++;

    if (taskPhase !== this.currentPhase) {
      this.completedTasksInPhase = 0;
      this.currentPhase = taskPhase;
    }

    this.completedTasksInPhase++;

    return this.shouldCommit();
  }

  /**
   * Mark a phase as completed
   */
  phaseCompleted(): boolean {
    // Reset phase counter
    this.completedTasksInPhase = 0;

    // If strategy is per-phase, we should commit
    return this.strategy === 'per-phase';
  }

  /**
   * Check if a commit should be made now
   */
  private shouldCommit(): boolean {
    switch (this.strategy) {
      case 'per-task':
        return true;

      case 'per-5-tasks':
        return this.completedTasksSinceLastCommit >= 5;

      case 'per-phase':
        // Will be handled by phaseCompleted()
        return false;

      case 'none':
        return false;

      default:
        return false;
    }
  }

  /**
   * Reset commit counter (after a commit is made)
   */
  resetCommitCounter(): void {
    this.completedTasksSinceLastCommit = 0;
  }

  /**
   * Get accumulated task count for commit message
   */
  getTaskCountSinceLastCommit(): number {
    return this.completedTasksSinceLastCommit;
  }
}
